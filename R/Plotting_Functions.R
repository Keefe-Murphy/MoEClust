#' Generalised Pairs Plots for MoEClust Mixture Models
#'
#' Produces a matrix of plots showing pairwise relationships between continuous response variables and continuous/categorical associated covariates, as well as the clustering achieved, according to fitted MoEClust models.
#' @param res An object of class \code{"MoEClust"} generated by \code{\link{MoE_clust}}, or an object of class \code{"MoECompare"} generated by \code{\link{MoE_compare}}.
#' @param response.type The type of plot desired for the scatter plots comparing continuous response variables. Defaults to \code{"points"}, but points can also be sized according to their associated clustering \code{"uncertainty"}, or the bivariate \code{"density"} can be displayed.
#' @param scatter.type A vector of length 2 giving the plot type for the upper and lower triangular portions of the plot, respectively, pertaining to the associated covariates. Defaults to \code{"lm"} for covariate vs. response panels and \code{"points"} otherwise. Only relevant for models with continuous covariates in the gating &/or expert network. \code{"ci"} and \code{"lm"} type plots are only produced for plots of covariates against response, and never response vs. response or covariate vs. covariate.
#' @param conditional A vector of length 2 giving the plot type for the upper and lower triangular portions of the plot, respectively, for plots involving a mix of categorical and continuous variables. Defaults to \code{"stripplot"} in the upper triangle and \code{"boxplot"} in the lower triangle (see \code{\link[lattice]{panel.stripplot}} and \code{\link[lattice]{panel.bwplot}}). Only relevant for models with categorical covariates in the gating &/or expert network. Comparisons of two categorical variables (which can only ever be covariates) are always displayed via mosaic plots (see \code{\link[vcd]{strucplot}}).
#' @param addEllipses Logical indicating whether to add ellipses with axes corresponding to the within-cluster covariances for the response data (defaults to \code{TRUE}).
#' @param bg.col A vector of length 5 containing background colours for plots against the MAP classification, response vs. response, covariate vs. response, response vs. covariate, and covariate vs. covariate panels, respectively. Defaults to \code{c("ivory", "white", "snow", "snow", "cornsilk")}.
#' @param diagonal By default, the diagonal to the top left to the bottom right is used for displaying the marginal distributions of variables. Specifying \code{"off"} will place the diagonal running from the top right down to the bottom left.
#' @param outer.margins A list of length 4 with units as components named bottom, left, top, and right, giving the outer margins; the defaults uses two lines of text. A vector of length 4 with units (ordered properly) will work, as will a vector of length 4 with numeric variables (interpreted as lines).
#' @param outer.labels The default is \code{NULL}, for alternating labels around the perimeter. If \code{"all"}, all labels are printed, and if \code{"none"}, no labels are printed.
#' @param outer.rot A 2-vector (\code{x}, \code{y}) rotating the top/bottom outer labels \code{x} degrees and the left/right outer labels \code{y} degrees. Only works for categorical labels of boxplot and mosaic panels.
#' @param gap The gap between the tiles; defaulting to 0.05 of the width of a tile.
#' @param buffer The fraction by which to expand the range of quantitative variables to provide plots that will not truncate plotting symbols. Defaults to 2 percent of range currently.
#' @param scatter.pars A list supplying select parameters for the continuous vs. continuous scatter plots. \code{NULL} is equivalent to \code{list(pch=res$classification, size=unit(0.25, "char"), col=res$classification, lcol=res$classification, border.col="black")}, where \code{lcol} gives the colour of the fitted lines when \code{scatter.type} is one of \code{"ci"} or \code{"lm"}. Note that \code{scatter.pars$size} will be overridden when \code{response.type} is \code{"uncertainty"}.
#' @param stripplot.pars \code{NULL} is equivalent to \code{list(pch=res$classification, size=unit(0.5, "char"), col=res$classification, jitter=TRUE)}.
#' @param barcode.pars \code{NULL} is equivalent to \code{list(nint=0, ptsize=unit(0.25, "char"), ptpch=1, bcspace=NULL, use.points=FALSE)}. See \code{\link[barcode]{barcode}}.
#' @param mosaic.pars \code{NULL}. Currently \code{shape, gp_labels, gp} and \code{gp_args} are passed through to \code{\link[vcd]{strucplot}} for producing mosaic tiles.
#' @param axis.pars \code{NULL} is equivalent to \code{list(n.ticks=5, fontsize=9)}.
#' @param diag.pars \code{NULL} is equivalent to \code{list(fontsize=9, show.hist=TRUE, hist.color=hist.color)}, where \code{hist.color} is a vector of length 5, giving the colours for the MAP classification, response variables, gating covariates, expert covariates, and covariates entering both networks, respectively. By default, response variables are \code{"black"}, covariates of any kind are \code{"grey"}, and the MAP classification is \code{"gold"}.
#' @param ... Catches unused arguments.
#'
#' @importFrom barcode "barcode"
#' @importFrom grid "gpar" "grid.lines" "grid.newpage" "grid.points" "grid.rect" "grid.text" "grid.xaxis" "grid.yaxis" "popViewport" "pushViewport" "unit" "upViewport" "viewport"
#' @importFrom lattice "panel.abline" "panel.barchart" "panel.bwplot" "panel.histogram" "panel.lines" "panel.points" "panel.stripplot" "trellis.par.get" "trellis.par.set"
#' @importFrom vcd "strucplot"
#'
#' @return A generalised pairs plot.
#' @note For \code{MoEClust} models with more than one associated covariate (entering either network), fitted lines produced in continuous covariate vs. continuous response scatter plots via \code{scatter.type="lm"} or \code{scatter.type="ci"} will \strong{NOT} correspond to the coefficients in the expert network (\code{res$expert}).
#'
#' \code{\link{plot.MoEClust}} is a wrapper to \code{\link{MoE_gpairs}} which accepts the default arguments, and also produces other types of plots.
#' @export
#' @author Keefe Murphy - \href{keefe.murphy@ucd.ie}{<keefe.murphy@ucd.ie>}
#' @references Emerson, J.W., Green, W.A., Schloerke, B., Crowley, J., Cook, D., Hofmann, H. and Wickham, H. (2013). The Generalized Pairs Plot. \emph{Journal of Computational and Graphical Statistics}, 22(1):79-91.
#' @seealso \code{\link{MoE_clust}}, \code{\link{plot.MoEClust}}, \code{\link[lattice]{panel.stripplot}}, \code{\link[lattice]{panel.bwplot}}, \code{\link[vcd]{strucplot}}, \code{\link[barcode]{barcode}}
#' @examples
#' data(ais)
#' hema  <- ais[,3:7]
#' sex   <- ais$sex
#' BMI   <- ais$BMI
#'
#' res   <- MoE_clust(hema, G=3, gating= ~ sex, expert= ~ sex + BMI, modelNames="EEE")
#' MoE_gpairs(res)
#'
#' # Produce the same plot with a barchart in the lower triangle,
#' # with confidence intervals on the scatter plots,
#' # different colours for histograms of covariates in the gating/expert/both networks.
#' # Size points in the response vs. response panels by their clustering uncertainty.
#' # Also use different colours for response vs. covariate & covariate vs. response panels.
#' MoE_gpairs(res, scatter.type=c("ci", "points"), conditional=c("stripplot", "barcode"),
#'            diag.pars=list(hist.color=c("gold", "black", "cyan", "navy", "hotpink")),
#'            bg.col=c("oldlace", "white", "seashell", "whitesmoke", "cornsilk"))
MoE_gpairs          <- function(res, response.type = c("points", "uncertainty", "density"), scatter.type = c("lm", "points"), conditional = c("stripplot", "boxplot"), addEllipses = TRUE, bg.col = c("ivory", "white", "snow", "snow", "cornsilk"),
                                diagonal = c("on", "off"), outer.margins = list(bottom=unit(2, "lines"), left=unit(2, "lines"), top=unit(2, "lines"), right=unit(2, "lines")), outer.labels = NULL, outer.rot = c(0, 90),
                                gap = 0.05, buffer = 0.02, scatter.pars = NULL, stripplot.pars = NULL, barcode.pars = NULL, mosaic.pars = NULL, axis.pars = NULL, diag.pars = NULL, ...) {
  UseMethod("MoE_gpairs")
}

#' @method MoE_gpairs MoEClust
#' @export
MoE_gpairs.MoEClust <- function(res, response.type = c("points", "uncertainty", "density"), scatter.type = c("ci", "points"), conditional = c("stripplot", "boxplot"), addEllipses = TRUE, bg.col = c("ivory", "white", "snow", "snow", "cornsilk"),
                                diagonal = c("on", "off"), outer.margins = list(bottom=unit(2, "lines"), left=unit(2, "lines"), top=unit(2, "lines"), right=unit(2, "lines")), outer.labels = NULL, outer.rot = c(0, 90),
                                gap = 0.05, buffer = 0.02, scatter.pars = NULL, stripplot.pars = NULL, barcode.pars = NULL, mosaic.pars = NULL, axis.pars = NULL, diag.pars = NULL, ...) {

  res   <- if(inherits(res, "MoECompare")) res$optimal else res
  dat   <- res$data
  net   <- res$net.covs
  dcol  <- ncol(dat) + 1
  class <- as.character(res$classification)
  x     <- cbind(MAP=as.factor(class), dat, net)
  zc    <- function(x) length(unique(x)) <= 1
  saxzc <- sapply(x, zc)
  nrm   <- sum(saxzc, na.rm=TRUE)
  if(any(saxzc, na.rm=TRUE)) {                        warning(paste(nrm, "column", ifelse(nrm > 1, "s", ""), " with less than two distinct values eliminated"), call.=FALSE)
   dcol <- sum(which(saxzc) < dcol)
   x    <- x[,!saxzc]
  }
  N     <- ncol(x)
  Nseq  <- seq_len(N)
  z     <- res$z
  G     <- res$G
  both  <- attr(net, "Both")
  gate  <- setdiff(attr(net, "Gating"), both)
  if(G  == 1 && any(!is.na(gate)))                    warning("Gating covariates are plotted even though they cannot enter single-component models", call.=FALSE)
  expx  <- setdiff(attr(net, "Expert"), both)
  both  <- which(names(net) %in% both) + dcol
  gate  <- which(names(net) %in% gate) + dcol
  expx  <- which(names(net) %in% expx) + dcol
  both[is.na(both)] <- 0L
  gate[is.na(gate)] <- 0L
  expx[is.na(expx)] <- 0L
  both  <- if(length(both) == 0) 0L else both
  gate  <- if(length(gate) == 0) 0L else gate
  expx  <- if(length(expx) == 0) 0L else expx
  if(N  == 1)                                         stop("Cannot produce gpairs plot with only one column")
  U     <- sort(unique(class))
  L     <- length(U)
  noise <- any(class == 0)
  if(L  <= length(mclust.options("classPlotSymbols"))) {
    symbols   <- mclust.options("classPlotSymbols")
    if(noise) {
      symbols[symbols == 16] <- symbols[G + 1]
      symbols[G + 1]         <- 16
    }
  } else if(L <= 9)  {
    symbols   <- as.character(1:9)
  } else if(L <= 26) {
    symbols   <- LETTERS
  } else if(length(symbols)  == 1) {
    symbols   <- rep(symbols, L)
  }
  if(L <= length(mclust.options("classPlotColors"))) {
    colors    <- mclust.options("classPlotColors")[seq_len(L)]
    if(noise)  {
      colors[colors == "black"] <- colors[G + 1]
      colors[G + 1]             <- "grey70"
    }
  } else if(length(colors) == 1) colors <- rep(colors, L)
  if(length(symbols) < L) {                           warning("More symbols needed to show classification", call.=FALSE)
    symbols <- rep(16, L)
  }
  if(length(colors)  < L) {                           warning("More colors needed to show classification", call.=FALSE)
    colors <- rep("black", L)
  }
  scatter.type <- if(length(scatter.type) == 1) rep(scatter.type, 2) else scatter.type
  conditional  <- if(length(conditional)  == 1) rep(conditional,  2) else conditional
  bg.col       <- if(length(bg.col)       == 1) rep(bg.col,       5) else bg.col
  if(!is.character(response.type))                    stop("'response.type' must be a character string")
  response.type         <- match.arg(response.type)
  if(response.type      == "density")                 stop("The 'density' option to 'response.type' is not yet implemented")
  uncertainty  <- res$uncertainty
  uncertainty  <- 0.5    * (uncertainty - min(uncertainty))/diff(range(uncertainty))
  if(length(scatter.type)  != 2 ||
            !all(is.character(scatter.type)))         stop("'scatter.type' must be a character vector of length 2")
  if(length(conditional)   != 2 ||
            !all(is.character(conditional)))          stop("'conditional' must be a character vector of length 2")
  if(!all(scatter.type %in% c("ci", "lm", "points"))) stop("The entries of 'scatter.type' must be one of 'ci', 'lm', or 'points'")
  if(!all(conditional  %in% c("stripplot",
                             "boxplot", "barcode")))  stop("The entries of 'conditional' must be one of 'stripplot', 'boxplot', or 'barcode'")
  if(length(addEllipses)   != 1 ||
     !is.logical(addEllipses))                        stop("'addEllipses' must be a single logical indicator")
  upr.exp  <- scatter.type[1]
  low.exp  <- scatter.type[2]
  upr.cond <- conditional[1]
  low.cond <- conditional[2]
  if(length(bg.col)     != 5)                         stop("'bg.col' must be a vector of length 1 or 5 containing valid colours")
  if(!missing(diagonal) &&
     (length(diagonal)   > 1    ||
      !is.character(diagonal)))                       stop("'diagonal' must be a single character string")
  diagonal <- match.arg(diagonal)
  if(!is.list(outer.margins)) {
    if(length(outer.margins) == 4) {
      outer.margins     <- ifelse(inherits(outer.margins[1], "units"), list(bottom=outer.margins[1], left=outer.margins[2], top=outer.margins[3], right=outer.margins[4]), list(bottom=unit(outer.margins[1], "lines"), left=unit(outer.margins[2], "lines"), top=unit(outer.margins[3], "lines"), right=unit(outer.margins[4], "lines")))
    } else                                            stop("'outer.margins' are not valid")
  }
  if(is.null(outer.labels)) {
    outer.labels$top    <- rep(FALSE, N)
    outer.labels$top[seq(2,  N, by=2)] <- TRUE
    outer.labels$left   <- rep(FALSE, N)
    outer.labels$left[seq(1, N, by=2)] <- TRUE
    outer.labels$right  <- !outer.labels$left
    outer.labels$bottom <- !outer.labels$top
  } else {
    if(pmatch(as.character(outer.labels),         "all", nomatch=FALSE)) {
      all.labeling      <- TRUE
    } else if(pmatch(as.character(outer.labels), "none", nomatch=FALSE)) {
      all.labeling      <- FALSE
    } else                                            stop("Invalid 'outer.labels'")
    outer.labels        <- NULL
    outer.labels$top    <-
    outer.labels$left   <-
    outer.labels$bottom <-
    outer.labels$right  <- rep(all.labeling, N)
  }
  if(length(outer.rot)  != 2    ||
    !all(is.numeric(outer.rot)) ||
     any(outer.rot       < 0))                        stop("Invalid 'outer.rot': must be a strictly non-negative numeric vector of length 2")
  class                 <- as.numeric(class)
  class[class == 0]     <- G + 1
  if(length(gap)        != 1    || (!is.numeric(gap)    ||
     gap    < 0))                                     stop("'gap' must be single strictly non-negative number")
  if(length(buffer)     != 1    || (!is.numeric(buffer) ||
     buffer < 0))                                     stop("'buffer' must be single strictly non-negative number")
  if(is.null(scatter.pars$pch))      {
    scatter.pars$pch    <- symbols[class]
  }
  if(is.null(scatter.pars$size))     {
    scatter.pars$size   <- unit(0.25, "char")
  }
  if(is.null(scatter.pars$col))      {
    scatter.pars$col    <- colors[class]
  }
  if(is.null(scatter.pars$lcol))     {
    scatter.pars$lcol   <- colors[seq_len(G)]
  }
  if(is.null(axis.pars$n.ticks))     {
    axis.pars$n.ticks   <- 5
  }
  if(is.null(axis.pars$fontsize))    {
    axis.pars$fontsize  <- 9
  }
  if(axis.pars$n.ticks   < 3)        {                warning("Fewer than 3 axis ticks might cause problems")
    axis.pars$n.ticks   <- 3
  }
  if(is.null(diag.pars$fontsize))    {
    diag.pars$fontsize  <- 9
  }
  if(is.null(diag.pars$show.hist))   {
    diag.pars$show.hist <- TRUE
  }
  if(is.null(diag.pars$hist.color))  {
   diag.pars$hist.color <- c("gold", "black", "grey", "grey", "grey")
  } else {
   diag.pars$hist.color <- if(length(diag.pars$hist.color) == 1) rep(diag.pars$hist.color, 5) else diag.pars$hist.color
   if(length(diag.pars$hist.color) != 5)              stop("'diag.pars$hist.color' must be a vector of length 1 or 5")
  }
  hist.col              <- diag.pars$hist.color
  diag.pars$hist.color  <- replace(Nseq,                 Nseq  <=  dcol,                     hist.col[2])
  diag.pars$hist.color  <- replace(diag.pars$hist.color, Nseq  ==  1 & names(x)[1] == "MAP", hist.col[1])
  diag.pars$hist.color  <- replace(diag.pars$hist.color, Nseq %in% gate,                     hist.col[3])
  diag.pars$hist.color  <- replace(diag.pars$hist.color, Nseq %in% expx,                     hist.col[4])
  diag.pars$hist.color  <- replace(diag.pars$hist.color, Nseq %in% both,                     hist.col[5])
  if(is.null(stripplot.pars$pch))    {
    stripplot.pars$pch  <- symbols[class]
  }
  if(is.null(stripplot.pars$col))    {
    stripplot.pars$col  <- colors[class]
  }
  if(is.null(stripplot.pars$size))   {
    stripplot.pars$size <- unit(0.5, "char")
  }
  if(is.null(stripplot.pars$jitter)) {
  stripplot.pars$jitter <- TRUE
  }
  if(is.null(barcode.pars$nint))     {
    barcode.pars$nint   <- 0
  }
  if(is.null(barcode.pars$ptsize))   {
    barcode.pars$ptsize <- unit(0.25, "char")
  }
  if(is.null(barcode.pars$ptpch))    {
    barcode.pars$ptpch  <- 1
  }
  if(is.null(barcode.pars$bcspace))  {
   barcode.pars$bcspace <- NULL
  }
  if(is.null(barcode.pars$use.points)) {
    barcode.pars$use.points <- FALSE
  }
  if(is.null(mosaic.pars$gp_labels)) {
    mosaic.pars$gp_labels   <- gpar(fontsize=9)
  }
  if(is.null(mosaic.pars$gp_args))   {
    mosaic.pars$gp_args <- list()
  }
  grid.newpage()
  vp.main    <- viewport(x=outer.margins$bottom, y=outer.margins$left,
                         width=unit(1,  "npc") - outer.margins$right - outer.margins$left,
                         height=unit(1, "npc") - outer.margins$top   - outer.margins$bottom,
                         just=c("left", "bottom"), name="main", clip="off")
  pushViewport(vp.main)
  for(i in Nseq)   {
    for(j in Nseq) {
      bg     <- if(i == 1 || j == 1) bg.col[1] else if(i <= dcol && j <= dcol) bg.col[2] else if(i > dcol && j > dcol) bg.col[5] else if(j > dcol && i <= dcol) bg.col[3] else bg.col[4]
      labelj <- switch(diagonal, on=j, off=N - j + 1)
      x[is.infinite(x[,i]), i] <- NA
      x[is.infinite(x[,j]), j] <- NA
      vp     <- viewport(x=(labelj - 1)/N, y=1 - i/N, width=1/N, height=1/N, just=c("left", "bottom"), name=as.character(i * N + j))
      pushViewport(vp)
      vp.in  <- viewport(x=0.5, y=0.5, width=1 - gap, height=1 - gap, just=c("center", "center"), name=paste("IN", as.character(i * N + j)))
      pushViewport(vp.in)
      xpos   <- NULL
      if(i == 1 && outer.labels$top[j])    {
        xpos <- FALSE
      }
      if(i == N && outer.labels$bottom[j]) {
        xpos <- TRUE
      }
      ypos   <- NULL
      if(j == N && outer.labels$right[i])  {
        ypos <- FALSE
      }
      if(j == 1 && outer.labels$left[i])   {
        ypos <- TRUE
      }
      if(!is.null(ypos) && diagonal == "off") {
        ypos <- !ypos
      }
      if(i == j) {
        .diag_panel(x=x[,i], varname=names(x)[i], diag.pars=diag.pars, axis.pars=axis.pars, xpos=xpos, ypos=ypos, buffer=buffer, index=i, outer.rot=outer.rot)
      } else {
        if(is.factor(x[,i]) + is.factor(x[,j]) == 1) {
          if(i < j & upr.cond != "barcode") .boxplot_panel(x=x[,j], y=x[,i], type=upr.cond, axis.pars=axis.pars, xpos=xpos, ypos=ypos, buffer=buffer, stripplot.pars=stripplot.pars, outer.rot=outer.rot, bg=bg)
          if(i > j & low.cond != "barcode") .boxplot_panel(x=x[,j], y=x[,i], type=low.cond, axis.pars=axis.pars, xpos=xpos, ypos=ypos, buffer=buffer, stripplot.pars=stripplot.pars, outer.rot=outer.rot, bg=bg)
          if(i < j & upr.cond == "barcode") {
            pushViewport(viewport(gp=gpar(fill=bg)))
            if(is.factor(x[,i])) {
              barcode(x=split(x[,j], x[,i])[length(levels(x[,i])):1], horizontal=TRUE, xlim=NULL,
                      labelloc=ypos, axisloc=xpos, labelouter=TRUE, newpage=FALSE, fontsize=axis.pars$fontsize,
                      buffer=buffer, nint=barcode.pars$nint, ptsize=barcode.pars$ptsize, ptpch=barcode.pars$ptpch,
                      bcspace=barcode.pars$bcspace, use.points=barcode.pars$use.points)
            } else {
              if(!is.null(ypos)) ypos <- !ypos
              barcode(x=split(x[,i], x[,j])[length(levels(x[,j])):1], horizontal=FALSE, xlim=NULL,
                      labelloc=xpos, axisloc=ypos, labelouter=TRUE, newpage=FALSE, fontsize=axis.pars$fontsize,
                      buffer=buffer, nint=barcode.pars$nint, ptsize=barcode.pars$ptsize, ptpch=barcode.pars$ptpch,
                      bcspace=barcode.pars$bcspace, use.points=barcode.pars$use.points)
            }
            popViewport()
          }
          if(i > j & low.cond == "barcode") {
            pushViewport(viewport(gp=gpar(fill=bg)))
            if(is.factor(x[,i])) {
              barcode(x=split(x[,j], x[,i])[length(levels(x[,i])):1], horizontal=TRUE, xlim=NULL,
                      labelloc=ypos, axisloc=xpos, labelouter=TRUE, newpage=FALSE, fontsize=axis.pars$fontsize,
                      buffer=buffer, nint=barcode.pars$nint, ptsize=barcode.pars$ptsize, ptpch=barcode.pars$ptpch,
                      bcspace=barcode.pars$bcspace, use.points=barcode.pars$use.points)
            } else {
              if(!is.null(ypos)) ypos <- !ypos
              barcode(x=split(x[,i], x[,j])[length(levels(x[,j])):1], horizontal=FALSE, xlim=NULL,
                      labelloc=xpos, axisloc=ypos, labelouter=TRUE, newpage=FALSE, fontsize=axis.pars$fontsize,
                      buffer=buffer, nint=barcode.pars$nint, ptsize=barcode.pars$ptsize, ptpch=barcode.pars$ptpch,
                      bcspace=barcode.pars$bcspace, use.points=barcode.pars$use.points)
            }
            popViewport()
          }
        }
        if(is.factor(x[,i]) + is.factor(x[,j]) == 0) {
          .scatter_panel(x=x[,j], y=x[,i], type=ifelse(j > dcol && i <= dcol, upr.exp, ifelse(j <= dcol && i <= dcol, ifelse(addEllipses, "ellipses", "points"), low.exp)),
                         scatter.pars=scatter.pars, axis.pars=axis.pars, xpos=xpos, ypos=ypos, buffer=buffer, z=z, G=G, res=res, dimens=c(j - 1, i - 1), outer.rot=outer.rot,
                         bg=bg, uncertainty=if(response.type == "uncertainty" && (i <= dcol && j <= dcol)) uncertainty else NA)
        }
        if(is.factor(x[,i]) + is.factor(x[,j]) == 2) {
          .mosaic_panel(x=x[,j], y=x[,i], mosaic.pars=mosaic.pars, axis.pars=axis.pars, xpos=xpos, ypos=ypos, outer.rot=outer.rot, bg=bg)
        }
      }
      popViewport(1)
      upViewport()
    }
  }
  popViewport()
  invisible()
}

#' Plot MoEClust Gating Network
#'
#' Plots the gating network for fitted MoEClust models, i.e. the observation index against the mixing proportions for that observation, coloured by cluster.
#' @param res An object of class \code{"MoEClust"} generated by \code{\link{MoE_clust}}, or an object of class \code{"MoECompare"} generated by \code{\link{MoE_compare}}.
#' @param type,xlab,ylab,ylim These graphical parameters retain their definitions from \code{\link[graphics]{matplot}}.
#' @param ... Catches unused arguments, or additional arguments to be passed to \code{\link[graphics]{matplot}}.
#'
#' @importFrom graphics "matplot"
#' @return A plot of the gating network of the fitted model.
#' @author Keefe Murphy - \href{keefe.murphy@ucd.ie}{<keefe.murphy@ucd.ie>}
#' @note \code{\link{plot.MoEClust}} is a wrapper to \code{\link{MoE_plotGate}} which accepts the default arguments, and also produces other types of plots.
#' @seealso \code{\link{MoE_clust}}, \code{\link{plot.MoEClust}}, \code{\link[graphics]{matplot}}
#' @export
#'
#' @examples
#' data(ais)
#' res <- MoE_clust(ais[,3:7], gating= ~ ais$sex, G=3, modelNames="VVE")
#' MoE_plotGate(res)
MoE_plotGate  <- function(res, type = "l", xlab = "Observation", ylab = expression(tau[g]), ylim = c(0, 1), ...) {
  UseMethod("MoE_plotGate")
}

#' @method MoE_plotGate MoEClust
#' @export
MoE_plotGate.MoEClust   <- function(res, type = "l", xlab = "Observation", ylab = expression(tau[g]), ylim = c(0, 1), ...) {
  res         <- if(inherits(res, "MoECompare")) res$optimal else res
  Tau         <- .mat_byrow(res$parameters$pro, nrow=res$n, ncol=res$G)
    matplot(Tau, type=type, xlab=xlab, ylab=ylab, ylim=ylim, ...)
    invisible()
}

#' Model Selection Criteria Plot for MoEClust Models
#'
#' Plots the BIC, ICL, or AIC values of a fitted \code{MoEClust} object.
#' @param res An object of class \code{"MoEClust"} generated by \code{\link{MoE_clust}}, or an object of class \code{"MoECompare"} generated by \code{\link{MoE_compare}}.
#' @param criterion The criterion to be plotted. Defaults to \code{"bic"}.
#' @param ... Catches other arguments, or additional arguments to be passed to \code{\link[mclust]{plot.mclustBIC}} (or equivalent functions for the other \code{criterion} arguments).
#'
#' @importFrom mclust "plot.mclustBIC" "plot.mclustICL"
#' @return A plot of the values of the chosen \code{criterion}.
#' @author Keefe Murphy - \href{keefe.murphy@ucd.ie}{<keefe.murphy@ucd.ie>}
#' @export
#' @note \code{\link{plot.MoEClust}} is a wrapper to \code{\link{MoE_plotCrit}} which accepts the default arguments, and also produces other types of plots.
#' @seealso \code{\link{MoE_clust}}, \code{\link{plot.MoEClust}}, \code{\link[mclust]{plot.mclustBIC}}
#'
#' @examples
#' \dontrun{
#' data(ais)
#' res <- MoE_clust(ais[,3:7], expert= ~ ais$sex)
#' MoE_plotCrit(res)}
MoE_plotCrit <- function(res, criterion = c("bic", "icl", "aic"), ...) {
  UseMethod("MoE_plotCrit")
}

#' @method MoE_plotCrit MoEClust
#' @export
MoE_plotCrit.MoEClust   <- function(res, criterion = c("bic", "icl", "aic"), ...) {
  if(!missing(criterion)      &&
     (length(criterion)  > 1  ||
      !is.character(criterion)))                      stop("'criterion' must be a single character string")
  res        <- if(inherits(res, "MoECompare")) res$optimal else res
  criterion  <- match.arg(criterion)
  crit       <- switch(criterion, bic=res$BIC, icl=res$ICL, res$AIC)
  crit       <- replace(crit, !is.finite(crit), NA)
    switch(criterion, bic=plot.mclustBIC(crit, ...), icl=plot.mclustICL(crit, ...), plot.mclustAIC(crit, ...))
    invisible()
}

#' Plot MoEClust Results
#'
#' Plot results for fitted MoE_clust mixture models with gating &/or expert network covariates: generalised pairs plots, model selection criteria, and the gating network are all currently visualisable.
#' @param x An object of class \code{"MoEClust"} generated by \code{\link{MoE_clust}}, or an object of class \code{"MoECompare"} generated by \code{\link{MoE_compare}}.
#' @param what The type of graph requested:
#' \itemize{
#' \item{\code{"gpairs"} - }{A generalised pairs plot. To further customise this plot, arguments to \code{\link{MoE_gpairs}} can be supplied.}
#' \item{\code{"gating"} - }{The gating network. To further customise this plot, arguments to \code{\link{MoE_plotGate}} can be supplied.}
#' \item{\code{"criterion"} - }{The model selection criteria. To further customise this plot, arguments to \code{\link{MoE_plotCrit}} and \code{\link[mclust]{plot.mclustBIC}} can be supplied.}
#' }
#' By default, all of the above graphs are produced.
#' @param ... Optional arguments to be passed to \code{\link{MoE_gpairs}}, \code{\link{MoE_plotGate}}, \code{\link{MoE_plotCrit}} and \code{\link[mclust]{plot.mclustBIC}}.
#'
#' @details For more flexibility in plotting, use \code{\link{MoE_gpairs}}, \code{\link{MoE_plotGate}}, \code{\link{MoE_plotCrit}} and \code{\link[mclust]{plot.mclustBIC}}
#' @importFrom graphics "matplot"
#' @importFrom barcode "barcode"
#' @importFrom grid "gpar" "grid.lines" "grid.newpage" "grid.points" "grid.rect" "grid.text" "grid.xaxis" "grid.yaxis" "popViewport" "pushViewport" "unit" "upViewport" "viewport"
#' @importFrom lattice "panel.abline" "panel.barchart" "panel.bwplot" "panel.histogram" "panel.lines" "panel.points" "panel.stripplot" "trellis.par.get" "trellis.par.set"
#' @importFrom mclust "plot.mclustBIC" "plot.mclustICL"
#' @importFrom utils "menu"
#' @importFrom vcd "strucplot"
#' @note Other types of plots are available by first calling \code{\link{as.Mclust}} on the fitted object, and then calling \code{\link[mclust]{plot.Mclust}} on the results.
#' @return The visualisation according to \code{"what"} of the results of a fitted \code{MoEClust} model.
#' @seealso \code{\link{MoE_clust}}, \code{\link{MoE_gpairs}}, \code{\link{MoE_plotGate}}, \code{\link{MoE_plotCrit}}, \code{\link{as.Mclust}}, \code{\link[mclust]{plot.Mclust}}
#' @author Keefe Murphy - \href{keefe.murphy@ucd.ie}{<keefe.murphy@ucd.ie>}
#' @export
#'
#' @examples
#' data(ais)
#' sex <- ais$sex
#' BMI <- ais$BMI
#' res <- MoE_clust(ais[,3:7], gating= ~ sex, expert= ~ BMI, G=3, modelNames="VVE")
#'
#' # Plot the gating network
#' plot(res, what="gating")
#'
#' # Produce a generalised pairs plot
#' plot(res, what="gpairs")
#'
#' # Modify the gpairs plot by passing arguments to MoE_gpairs()
#' plot(res, what="gpairs", response.type="uncertainty",
#'      scatter.type="lm", addEllipses=FALSE)
plot.MoEClust <- function(x, what=c("gpairs", "gating", "criterion"), ...) {
  if(!missing(what) && !all(is.character(what)))      stop("'what' must be a character string")
  what        <- match.arg(what, several.ok=TRUE)
  if(interactive()  && length(what) > 1) {
    title     <- "MoEClust Plots"
    choice    <- menu(what, graphics=FALSE, title=title)
    while(choice    != 0) {
      switch(what[choice], criterion=MoE_plotCrit(x, ...), gpairs=MoE_gpairs(x, ...), MoE_plotGate(x, ...))
      choice  <- menu(what, graphics=FALSE, title=title)
    }
  } else if(length(what)  > 1) {                      stop("'what' must be a single character string for non-interactive sessions")
  } else {
    switch(what, criterion=MoE_plotCrit(x, ...), gpairs=MoE_gpairs(x, ...), MoE_plotGate(x, ...))
  }
    invisible()
}

#' @importFrom lattice "panel.lines" "panel.points"
.mvn2D_panel <- function(mu, sigma, k = 15, alone = FALSE, col = rep("grey30", 3), pch = 8, lty = c(1, 2), lwd = c(1, 1)) {
  ev         <- eigen(sigma, symmetric = TRUE)
  s          <- sqrt(rev(sort(ev$values)))
  V          <- ev$vectors[,rev(order(ev$values))]
  theta      <- (0:k)  * (pi/(2 * k))
  x          <- s[1]   * cos(theta)
  y          <- s[2]   * sin(theta)
  xy         <- sweep(tcrossprod(cbind(c(x, -x, -x, x), c(y, y, -y, -y)), V), MARGIN=2, STATS=mu, FUN="+")
  l          <- length(x)
  i          <- seq_len(l)
  for(k in seq_len(4)) {
    panel.lines(xy[i,], col=col[1], lty=lty[1], lwd=lwd[1])
    i        <- i + l
  }
  x          <- s[1]
  y          <- s[2]
  xy         <- sweep(tcrossprod(cbind(c(x, -x, 0, 0), c(0, 0, y, -y)),   V), MARGIN=2, STATS=mu, FUN="+")
  panel.lines(xy[1:2,], col=col[2], lty=lty[2], lwd=lwd[2])
  panel.lines(xy[3:4,], col=col[2], lty=lty[2], lwd=lwd[2])
  panel.points(mu[1], mu[2], col=col[3], pch=pch)
    invisible()
}

#' @importFrom grid "gpar" "grid.text" "grid.xaxis" "grid.yaxis" "unit"
.draw_axis <- function(x, y, axis.pars, xpos, ypos, cat.labels = NULL, horiz = NULL, xlim = NULL, ylim = NULL, outer.rot) {
  x        <- as.numeric(x)
  y        <- as.numeric(y)
  if(is.null(xlim)) {
    px     <- pretty(x, axis.pars$n.ticks)
    px     <- px[px > min(x, na.rm=TRUE)    & px < max(x, na.rm=TRUE)]
  } else {
    px     <- pretty(xlim, axis.pars$n.ticks)
    px     <- px[px > min(xlim, na.rm=TRUE) & px < max(xlim, na.rm=TRUE)]
  }
  if(is.null(ylim)) {
    py     <- pretty(y, axis.pars$n.ticks)
    py     <- py[py > min(y, na.rm=TRUE)    & py < max(y, na.rm=TRUE)]
  } else {
    py     <- pretty(ylim, axis.pars$n.ticks)
    py     <- py[py > min(ylim, na.rm=TRUE) & py < max(ylim, na.rm=TRUE)]
  }
  k        <- length(cat.labels)
  if(!is.null(xpos)) {
    if(!is.null(cat.labels) && !horiz) {
      grid.text(cat.labels, x=unit(seq_len(k), "native"), y=unit(rep(1 * (1 - xpos), k), "npc") + unit(rep(-1 * xpos + 1 * (1 - xpos), k), "lines"), rot=outer.rot[1], gp=gpar(fontsize=axis.pars$fontsize))
    } else grid.xaxis(at=px, gp=gpar(fontsize=axis.pars$fontsize), main=xpos)
  }
  if(!is.null(ypos)) {
    if(!is.null(cat.labels) && horiz)  {
      grid.text(cat.labels, y=unit(seq_len(k), "native"), x=unit(rep(1 * (1 - ypos), k), "npc") + unit(rep(-1 * ypos + 1 * (1 - ypos), k), "lines"), rot=outer.rot[2], gp=gpar(fontsize=axis.pars$fontsize))
    } else grid.yaxis(at=py, gp=gpar(fontsize=axis.pars$fontsize), main=ypos)
  }
}

#' @importFrom grid "gpar" "grid.rect" "popViewport" "pushViewport" "viewport"
#' @importFrom lattice "panel.bwplot" "panel.stripplot" "trellis.par.get" "trellis.par.set"
.boxplot_panel <- function(x, y, type, axis.pars, xpos, ypos, buffer, stripplot.pars, outer.rot, bg) {
  xlim         <- NULL
  ylim         <- NULL
  old.color    <- trellis.par.get("box.rectangle")$col
  trellis.par.set(name="box.rectangle", value=list(col="black"))
  trellis.par.set(name="box.umbrella",  value=list(col="black"))
  trellis.par.set(name="box.dot",       value=list(col="black"))
  trellis.par.set(name="plot.symbol",   value=list(col="black"))
  if(is.factor(x)) {
    cat.labels <- levels(x)
    k          <- length(levels(x))
    cat.var    <- as.numeric(x)
    cont.var   <- y
    horiz      <- FALSE
  } else {
    cat.labels <- levels(y)
    k          <- length(levels(y))
    cat.labels <- cat.labels[k:1]
    cat.var    <- k + 1 - as.numeric(y)
    cont.var   <- x
    horiz      <- TRUE
  }
  grid.rect(gp=gpar(fill=bg))
  if(horiz) {
    xlim       <- range(cont.var, na.rm=TRUE) + c(-buffer * (max(cont.var, na.rm=TRUE) - min(cont.var, na.rm=TRUE)), buffer * (max(cont.var, na.rm=TRUE) - min(cont.var, na.rm=TRUE)))
    pushViewport(viewport(xscale=xlim, yscale=c(0.5, max(cat.var, na.rm=TRUE) + 0.5)))
    if(is.null(ypos)) cat.labels <- NULL
    .draw_axis(x=cont.var, y=cat.var, axis.pars=axis.pars, xpos=xpos, ypos=ypos, cat.labels=cat.labels, horiz=horiz, xlim=xlim, ylim=ylim, outer.rot=outer.rot)
    popViewport(1)
    pushViewport(viewport(xscale=xlim, yscale=c(0.5, max(cat.var, na.rm=TRUE) + 0.5), clip=TRUE))
    if(type == "boxplot")   panel.bwplot(cont.var, cat.var, horizontal=horiz, col="black", pch="|", gp=gpar(box.umbrella=list(col="black")))
    if(type == "stripplot") panel.stripplot(cont.var, cat.var, horizontal=horiz, jitter.data=stripplot.pars$jitter, col=stripplot.pars$col, cex=stripplot.pars$size, pch=stripplot.pars$pch)
  } else {
    ylim       <- range(cont.var, na.rm=TRUE) + c(-buffer * (max(cont.var, na.rm=TRUE) - min(cont.var, na.rm=TRUE)), buffer * (max(cont.var, na.rm=TRUE) - min(cont.var, na.rm=TRUE)))
    pushViewport(viewport(yscale=ylim, xscale=c(0.5, max(cat.var, na.rm=TRUE) + 0.5)))
    if(is.null(xpos)) cat.labels <- NULL
    .draw_axis(x=cat.var, y=cont.var, axis.pars=axis.pars, xpos=xpos, ypos=ypos, cat.labels=cat.labels, horiz=horiz, xlim=xlim, ylim=ylim, outer.rot=outer.rot)
    popViewport(1)
    pushViewport(viewport(yscale=ylim, xscale=c(0.5, max(cat.var, na.rm=TRUE) + 0.5), clip=TRUE))
    if(type == "boxplot")   panel.bwplot(cat.var, cont.var, horizontal=horiz, col="black", pch="|", gp=gpar(box.umbrella=list(col="black")))
    if(type == "stripplot") panel.stripplot(cat.var, cont.var, horizontal=horiz, jitter.data=stripplot.pars$jitter,
                                            col=stripplot.pars$col, cex=stripplot.pars$size, pch=stripplot.pars$pch)
  }
  popViewport(1)
  trellis.par.set(name="box.rectangle", value=list(col=old.color))
  trellis.par.set(name="box.umbrella",  value=list(col=old.color))
  trellis.par.set(name="box.dot",       value=list(col=old.color))
  trellis.par.set(name="plot.symbol",   value=list(col=old.color))
}

#' @importFrom grid "gpar" "grid.rect" "grid.text" "popViewport" "pushViewport" "viewport"
#' @importFrom lattice "panel.barchart" "panel.histogram"
.diag_panel <- function(x, varname, diag.pars, axis.pars, xpos, ypos, buffer, index, outer.rot) {
  x         <- x[!is.na(x)]
  xlim      <- range(as.numeric(x), na.rm=TRUE) + c(-buffer * (max(as.numeric(x), na.rm=TRUE) - min(as.numeric(x), na.rm=TRUE)), buffer * (max(as.numeric(x), na.rm=TRUE) - min(as.numeric(x), na.rm=TRUE)))
  ylim      <- xlim
  pushViewport(viewport(xscale=xlim, yscale=ylim))
  .draw_axis(x=as.numeric(x), y=as.numeric(x), axis.pars=axis.pars, xpos=xpos, ypos=ypos, cat.labels=NULL, horiz=NULL, xlim=xlim, ylim=ylim, outer.rot=outer.rot)
  popViewport(1)
  pushViewport(viewport(xscale=xlim, yscale=ylim, clip=TRUE))
  if(!diag.pars$show.hist) {
    grid.rect()
    grid.text(varname, 0.5, 0.5, gp=gpar(fontsize=diag.pars$fontsize, fontface=2))
  }
  popViewport(1)
  if(diag.pars$show.hist)  {
    if(!is.factor(x)) {
      pushViewport(viewport(xscale=xlim, yscale=c(0, 100), clip=TRUE))
      panel.histogram(as.numeric(x), breaks=NULL, type="percent", col=diag.pars$hist.color[index])
    } else {
      pushViewport(viewport(xscale=c(min(as.numeric(x), na.rm=TRUE) - 1, max(as.numeric(x), na.rm=TRUE) + 1), yscale=c(0, 100), clip=TRUE))
      tabx <- table(x)
      panel.barchart(seq_along(tabx), 100 * tabx/sum(tabx), horizontal=FALSE, col=diag.pars$hist.color[index])
    }
    grid.text(varname, 0.5, 0.85, gp=gpar(fontsize=diag.pars$fontsize))
    popViewport(1)
  }
}

#' @importFrom vcd "strucplot"
.mosaic_panel <- function(x, y, mosaic.pars, axis.pars, xpos, ypos, outer.rot, bg) {
  mosaic.pars$gp$fill <- bg
  if(!is.null(xpos)   && !is.null(ypos)) {
    strucplot(table(y, x), margins=c(0, 0, 0, 0), newpage=FALSE, pop=FALSE, keep_aspect_ratio=FALSE, shade=mosaic.pars$shade, legend=FALSE, gp=mosaic.pars$gp,
              gp_args=mosaic.pars$gp_args, labeling_args=list(tl_labels=c(xpos, !ypos), gp_labels=mosaic.pars$gp_labels, varnames=c(FALSE, FALSE), rot_labels=rep(outer.rot, 2)))
  } else {
    if(is.null(xpos)  && is.null(ypos))  {
      strucplot(table(y, x), margins=c(0, 0, 0, 0), shade=mosaic.pars$shade, legend=FALSE, gp=mosaic.pars$gp, gp_args=mosaic.pars$gp_args, newpage=FALSE, pop=FALSE, keep_aspect_ratio=FALSE, labeling=NULL)
    } else {
      if(is.null(xpos)) {
        strucplot(table(y, x), margins=c(0, 0, 0, 0), newpage=FALSE, pop=FALSE, keep_aspect_ratio=FALSE, shade=mosaic.pars$shade, legend=FALSE, gp=mosaic.pars$gp, gp_args = mosaic.pars$gp_args,
                  labeling_args=list(labels=c(TRUE, FALSE), tl_labels=c(ypos, FALSE), gp_labels=mosaic.pars$gp_labels, varnames=c(FALSE, FALSE), rot_labels=rep(outer.rot, 2)))
      } else strucplot(table(y, x), margins=c(0, 0, 0, 0), newpage=FALSE, pop=FALSE, keep_aspect_ratio=FALSE, shade=mosaic.pars$shade, legend=FALSE, gp=mosaic.pars$gp, gp_args = mosaic.pars$gp_args,
                       labeling_args=list(labels=c(FALSE, TRUE), tl_labels=c(FALSE, !xpos), gp_labels=mosaic.pars$gp_labels, varnames=c(FALSE, FALSE), rot_labels=rep(outer.rot, 2)))
    }
  }
}

#' @importFrom grid "gpar" "grid.lines" "grid.points" "grid.rect" "popViewport" "pushViewport" "viewport"
#' @importFrom lattice "panel.abline"
.scatter_panel <- function(x, y, type, scatter.pars, axis.pars, xpos, ypos, buffer, z, G, res, dimens, outer.rot, bg, uncertainty) {
  xlim    <- range(x, na.rm=TRUE) + c(-buffer * (max(x, na.rm=TRUE) - min(x, na.rm=TRUE)), buffer * (max(x, na.rm=TRUE) - min(x, na.rm=TRUE)))
  ylim    <- range(y, na.rm=TRUE) + c(-buffer * (max(y, na.rm=TRUE) - min(y, na.rm=TRUE)), buffer * (max(y, na.rm=TRUE) - min(y, na.rm=TRUE)))
  pushViewport(viewport(xscale=xlim, yscale=ylim))
  .draw_axis(x=x, y=y, axis.pars=axis.pars, xpos=xpos, ypos=ypos, cat.labels=NULL, horiz=NULL, xlim=xlim, ylim=ylim, outer.rot=outer.rot)
  popViewport(1)
  pushViewport(viewport(xscale=xlim, yscale=ylim, clip=TRUE))
  grid.rect(gp=gpar(fill=bg, col=scatter.pars$border.col))
  grid.points(x, y, pch=scatter.pars$pch, size=if(all(is.na(uncertainty))) scatter.pars$size else unit(uncertainty, "char"), gp=gpar(col=scatter.pars$col))
  if(type == "ellipses") {
    mu    <- array(res$parameters$mean[dimens,], c(2, G))
    sigma <- array(res$parameters$variance$sigma[dimens, dimens,], c(2, 2, G))
    for(g in seq_len(G)) .mvn2D_panel(mu = mu[,g], sigma = sigma[,,g], k = 15)
  }
  if(type == "lm") {
    for(g in seq_len(G)) {
      xy.lm <- lm(y ~ x, weights=z[,g])
      panel.abline(xy.lm$coef[1], xy.lm$coef[2], col=scatter.pars$lcol[g], lwd=1)
    }
  }
  if(type == "ci") {
    for(g in seq_len(G)) {
      xy.lm <- lm(y ~ x, weights=z[,g])
      xy    <- data.frame(x = seq(min(x, na.rm=TRUE), max(x, na.rm=TRUE), length.out=25))
      yhat  <- predict(xy.lm, newdata=xy, interval="confidence")
      ci    <- data.frame(lower=yhat[, "lwr"], upper=yhat[, "upr"])
      panel.abline(xy.lm$coef[1], xy.lm$coef[2], col=scatter.pars$lcol[g], lwd=1)
      grid.lines(x=xy$x, y=ci$lower, default.units="native", gp=gpar(col=scatter.pars$lcol[g], lwd=1, lty=2))
      grid.lines(x=xy$x, y=ci$upper, default.units="native", gp=gpar(col=scatter.pars$lcol[g], lwd=1, lty=2))
    }
  }
  popViewport(1)
}

#' @method plot mclustAIC
#' @importFrom mclust "plot.mclustBIC"
#' @export
plot.mclustAIC  <- function (x, ylab = "AIC", ...) {
  plot.mclustBIC(x, ylab = ylab, ...)
}

#' @method plot mclustDF
#' @importFrom mclust "plot.mclustBIC"
#' @export
plot.mclustDF   <- function (x, ylab = "DF", ...)  {
  plot.mclustBIC(x, ylab = ylab, ...)
}
