#' Generalised Pairs Plots for MoEClust Mixture Models
#'
#' Produces a matrix of plots showing pairwise relationships between continuous response variables and continuous/categorical associated covariates, as well as the clustering achieved, according to fitted MoEClust models.
#' @param res An object of class \code{"MoEClust"} generated by \code{\link{MoE_clust}}.
#' @param exp.type A vector of length 2 giving the plot type for the upper and lower triangular portions of the plot, respectively, pertaining to the associated covariates. Defaults to \code{"ci"} for covariate vs. response panels and \code{"points"} otherwise. Only relevant for models with continuous covariates in the gating &/or expert network. \code{"ci"} and \code{"lm"} type plots are only produced for plots of covariates against response, and never response vs. response.
#' @param conditional A vector of length 2 giving the plot type for the upper and lower triangular portions of the plot, respectively, for plots involving a mix of categorical and continuous variables. Defaults to \code{"stripplot"} in the upper triangle and \code{"boxplot"} in the lower triangle (see \code{\link[lattice]{panel.stripplot}} and \code{\link[lattice]{panel.bwplot}}). Only relevant for models with categorical covariates in the gating &/or expert network. Comparisons of two categorical variables (which can only ever be covariates) are always displayed via mosaic plots (see \code{\link[vcd]{strucplot}}).
#' @param addEllipses Logical indicating whether to add ellipses with axes corresponding to the within-cluster covariances for the response data (defaults to \code{TRUE}).
#' @param bg.col A vector of length 3 containing colours for response vs. response panels, panels involving a mix of response and covariates, and covariate vs. covariate panels. Defaults to \code{c("white", "snow", "cornsilk")}.
#' @param diagonal By default, the diagonal to the top left to the bottom right is used for displaying the marginal distributions of variables. Specifying \code{"off"} will place the diagonal running from the top right down to the bottom left.
#' @param outer.margins A list of length 4 with units as components named bottom, left, top, and right, giving the outer margins; the defaults uses two lines of text. A vector of length 4 with units (ordered properly) will work, as will a vector of length 4 with numeric variables (interpreted as lines).
#' @param outer.labels The default is \code{NULL}, for alternating labels around the perimeter. If \code{"all"}, all labels are printed, and if \code{"none"}, no labels are printed.
#' @param outer.rot A 2-vector (\code{x}, \code{y}) rotating the top/bottom outer labels \code{x} degrees and the left/right outer labels \code{y} degrees. Only works for categorical labels of boxplot and mosaic panels.
#' @param gap The gap between the tiles; defaulting to 0.05 of the width of a tile.
#' @param buffer The fraction by which to expand the range of quantitative variables to provide plots that will not truncate plotting symbols. Defaults to 2 percent of range currently.
#' @param scatter.pars A list supplying select parameters for the continuous vs. continuous scatter plots. \code{NULL} is equivalent to \code{list(pch=res$classification, size=unit(0.25, "char"), col=res$classification, lcol=res$classification, border.col="black")}, where \code{lcol} gives the colour of the fitted lines when \code{exp.type} is one of \code{"ci"} or \code{"lm"}.
#' @param stripplot.pars \code{NULL} is equivalent to \code{list(pch=res$classification, size=unit(0.5, "char"), col=res$classification, jitter=TRUE)}.
#' @param barcode.pars \code{NULL} is equivalent to \code{list(nint=0, ptsize=unit(0.25, "char"), ptpch=1, bcspace=NULL, use.points=FALSE)}. See \code{\link[barcode]{barcode}}.
#' @param mosaic.pars \code{NULL}. Currently \code{shape, gp_labels, gp} and \code{gp_args} are passed through to \code{\link[vcd]{strucplot}} for producing mosaic tiles. See \code{\link[vcd]{strucplot}}.
#' @param axis.pars \code{NULL} is equivalent to \code{list(n.ticks=5, fontsize=9)}.
#' @param diag.pars \code{NULL} is equivalent to \code{list(fontsize=9, show.hist=TRUE, hist.color=hist.color)}, where \code{hist.color} is a vector as long as the total number of unique variables in the response and gating &/or expert network. By default, response variables are \code{"black"} and covariates of any kind are \code{"grey70"}.
#'
#' @importFrom barcode "barcode"
#' @importFrom grid "gpar" "grid.lines" "grid.newpage" "grid.points" "grid.rect" "grid.text" "grid.xaxis" "grid.yaxis" "popViewport" "pushViewport" "unit" "upViewport" "viewport"
#' @importFrom lattice "panel.abline" "panel.barchart" "panel.bwplot" "panel.histogram" "panel.lines" "panel.points" "panel.stripplot" "trellis.par.get" "trellis.par.set"
#' @importFrom vcd "strucplot"
#'
#' @return A generalised pairs plot.
#' @note Generalised pairs plots cannot be produced for models fit to univariate data sets without associated covariates.
#'
#' @export
#' @references Emerson, J.W., Green, W.A., Schloerke, B., Crowley, J., Cook, D., Hofmann, H. and Wickham, H. (2013). The Generalized Pairs Plot. \emph{Journal of Computational and Graphical Statistics}, 22(1):79-91.
#' @seealso \code{\link{MoE_clust}}, \code{\link{plot.MoEClust}}, \code{\link[lattice]{panel.stripplot}}, \code{\link[lattice]{panel.bwplot}}, \code{\link[vcd]{strucplot}}, \code{\link[barcode]{barcode}}
#' @examples
#' data(ais)
#' hema  <- ais[,3:7]
#' sex   <- ais$sex
#' BMI   <- ais$BMI
#' sport <- factor(ais$sport, labels=seq_along(levels(ais$sport)))
#'
#' # Allow covariates to enter the mixing proportions
#' res   <- MoE_clust(hema, G=3, gating= ~ sex + BMI + sport, modelNames=c("EEE", "VEE", "VVE"))
#' MoE_gpairs(res)
MoE_gpairs          <- function(res, exp.type = c("ci", "points"), conditional = c("stripplot", "boxplot"), addEllipses = TRUE, bg.col = c("white", "snow", "cornsilk"),
                                diagonal = c("on", "off"), outer.margins = list(bottom=unit(2, "lines"), left=unit(2, "lines"), top=unit(2, "lines"), right=unit(2, "lines")),
                                outer.labels = NULL, outer.rot = c(0, 90), gap = 0.05, buffer = 0.02, scatter.pars = NULL, stripplot.pars = NULL, barcode.pars = NULL, mosaic.pars = NULL, axis.pars = NULL, diag.pars = NULL) {
  UseMethod("MoE_gpairs")
}

#' @method MoE_gpairs MoEClust
#' @export
MoE_gpairs.MoEClust <- function(res, exp.type = c("ci", "points"), conditional = c("stripplot", "boxplot"), addEllipses = TRUE, bg.col = c("white", "snow", "cornsilk"),
                                diagonal = c("on", "off"), outer.margins = list(bottom=unit(2, "lines"), left=unit(2, "lines"), top=unit(2, "lines"), right=unit(2, "lines")),
                                outer.labels = NULL, outer.rot = c(0, 90), gap = 0.05, buffer = 0.02, scatter.pars = NULL, stripplot.pars = NULL, barcode.pars = NULL, mosaic.pars = NULL, axis.pars = NULL, diag.pars = NULL) {

  dcol  <- ncol(res$data)
  class <- as.character(res$classification)
  z     <- res$z
  G     <- res$G
  x     <- cbind(res$data, res$net.covs)
  N     <- ncol(x)
  zc    <- function(x) length(unique(x)) <= 1
  saxzc <- sapply(x, zc)
  if(any(saxzc, na.rm=TRUE)) {                       warning(paste(sum(saxzc, na.rm = TRUE), "columns with less than two distinct values eliminated"), call.=FALSE)
    x   <- x[,!saxzc]
  }
  if(N  == 1)                                        stop("Cannot produce 'gpairs' plot for univariate data without associated covariates")
  U     <- sort(unique(class))
  L     <- length(U)
  noise <- any(class == 0)
  if(L  <= length(mclust.options("classPlotSymbols"))) {
    symbols   <- mclust.options("classPlotSymbols")
    if(noise) {
      symbols[symbols == 16] <- symbols[G + 1]
      symbols[G + 1]         <- 16
    }
  } else if(L <= 9)  {
    symbols   <- as.character(1:9)
  } else if(L <= 26) {
    symbols   <- LETTERS
  } else if(length(symbols)  == 1) {
    symbols   <- rep(symbols, L)
  }
  if(L <= length(mclust.options("classPlotColors"))) {
    colors    <- mclust.options("classPlotColors")[seq_len(L)]
    if(noise)  {
      colors[colors == "black"] <- colors[G + 1]
      colors[G + 1]             <- "grey70"
    }
  } else if(length(colors) == 1) colors <- rep(colors, L)
  if(length(symbols) < L) {                          warning("More symbols needed to show classification", call.=FALSE)
    symbols <- rep(16, L)
  }
  if(length(colors)  < L) {                          warning("More colors needed to show classification", call.=FALSE)
    colors <- rep("black", L)
  }
  exp.type    <- if(length(exp.type)    == 1) rep(exp.type,    2) else exp.type
  conditional <- if(length(conditional) == 1) rep(conditional, 2) else conditional
  bg.col      <- if(length(bg.col)      == 1) rep(bg.col,      3) else bg.col
  if(length(exp.type)      != 2 ||
            !all(is.character(exp.type)))            stop("'exp.type' must be a character vector of length 2")
  if(length(conditional)   != 2 ||
            !all(is.character(conditional)))         stop("'conditional' must be a character vector of length 2")
  if(!all(exp.type    %in% c("ci", "lm", "points"))) stop("The entries of 'exp.type' must be one of 'ci', 'lm', or 'points'")
  if(!all(conditional %in% c("stripplot",
                             "boxplot", "barcode"))) stop("The entries of 'conditional' must be one of 'stripplot', 'boxplot', or 'barcode'")
  if(length(addEllipses)   != 1 ||
     !is.logical(addEllipses))                       stop("'addEllipses' must be a single logical indicator")
  upr.exp  <- exp.type[1]
  low.exp  <- exp.type[2]
  upr.cond <- conditional[1]
  low.cond <- conditional[2]
  if(length(bg.col) != 3)                            stop("'bg.col' must be a vector of length 1 or 3 containing valid colours")
  if(length(diagonal)    > 2    ||
     !is.character(diagonal))                        stop("'diagonal' must be a single character string")
  diagonal <- match.arg(diagonal)
  if(!is.list(outer.margins)) {
    if(length(outer.margins) == 4) {
      outer.margins     <- ifelse(inherits(outer.margins[1], "units"), list(bottom=outer.margins[1], left=outer.margins[2], top=outer.margins[3], right=outer.margins[4]), list(bottom=unit(outer.margins[1], "lines"), left=unit(outer.margins[2], "lines"), top=unit(outer.margins[3], "lines"), right=unit(outer.margins[4], "lines")))
    } else                                           stop("'outer.margins' are not valid")
  }
  if(is.null(outer.labels)) {
    outer.labels$top    <- rep(FALSE, N)
    outer.labels$top[seq(2,  N, by=2)] <- TRUE
    outer.labels$left   <- rep(FALSE, N)
    outer.labels$left[seq(1, N, by=2)] <- TRUE
    outer.labels$right  <- !outer.labels$left
    outer.labels$bottom <- !outer.labels$top
  } else {
    if(pmatch(as.character(outer.labels),         "all", nomatch=FALSE)) {
      all.labeling      <- TRUE
    } else if(pmatch(as.character(outer.labels), "none", nomatch=FALSE)) {
      all.labeling      <- FALSE
    } else                                           stop("Invalid 'outer.labels'")
    outer.labels        <- NULL
    outer.labels$top    <-
    outer.labels$left   <-
    outer.labels$bottom <-
    outer.labels$right  <- rep(all.labeling, N)
  }
  if(length(outer.rot)  != 2    ||
    !all(is.numeric(outer.rot)) ||
     any(outer.rot       < 0))                       stop("Invalid 'outer.rot': must be a strictly non-negative numeric vector of length 2")
  class                 <- as.numeric(class)
  class[class == 0]     <- G + 1
  if(length(gap)        != 1    || (!is.numeric(gap)    ||
     gap    < 0))                                    stop("'gap' must be single strictly non-negative number")
  if(length(buffer)     != 1    || (!is.numeric(buffer) ||
     buffer < 0))                                    stop("'buffer' must be single strictly non-negative number")
  if(is.null(scatter.pars$pch))      {
    scatter.pars$pch    <- symbols[class]
  }
  if(is.null(scatter.pars$size))     {
    scatter.pars$size   <- unit(0.25, "char")
  }
  if(is.null(scatter.pars$col))      {
    scatter.pars$col    <- colors[class]
  }
  if(is.null(scatter.pars$lcol))     {
    scatter.pars$lcol   <- colors[seq_len(G)]
  }
  if(is.null(axis.pars$n.ticks))     {
    axis.pars$n.ticks   <- 5
  }
  if(is.null(axis.pars$fontsize))    {
    axis.pars$fontsize  <- 9
  }
  if(axis.pars$n.ticks   < 3)        {               warning("Fewer than 3 axis ticks might cause problems")
    axis.pars$n.ticks   <- 3
  }
  if(is.null(diag.pars$fontsize))    {
    diag.pars$fontsize  <- 9
  }
  if(is.null(diag.pars$show.hist))   {
    diag.pars$show.hist <- TRUE
  }
  if(is.null(diag.pars$hist.color))  {
   diag.pars$hist.color <- c(rep("black", dcol), rep("grey70", N - dcol))
  }
  if(is.null(stripplot.pars$pch))    {
    stripplot.pars$pch  <- symbols[class]
  }
  if(is.null(stripplot.pars$col))    {
    stripplot.pars$col  <- colors[class]
  }
  if(is.null(stripplot.pars$size))   {
    stripplot.pars$size <- unit(0.5, "char")
  }
  if(is.null(stripplot.pars$jitter)) {
  stripplot.pars$jitter <- TRUE
  }
  if(is.null(barcode.pars$nint))     {
    barcode.pars$nint   <- 0
  }
  if(is.null(barcode.pars$ptsize))   {
    barcode.pars$ptsize <- unit(0.25, "char")
  }
  if(is.null(barcode.pars$ptpch))    {
    barcode.pars$ptpch  <- 1
  }
  if(is.null(barcode.pars$bcspace))  {
   barcode.pars$bcspace <- NULL
  }
  if(is.null(barcode.pars$use.points)) {
    barcode.pars$use.points <- FALSE
  }
  if(is.null(mosaic.pars$gp_labels)) {
    mosaic.pars$gp_labels   <- gpar(fontsize=9)
  }
  if(is.null(mosaic.pars$gp_args))   {
    mosaic.pars$gp_args <- list()
  }
  grid.newpage()
  Nseq       <- seq_len(N)
  vp.main    <- viewport(x=outer.margins$bottom, y=outer.margins$left,
                         width=unit(1,  "npc") - outer.margins$right - outer.margins$left,
                         height=unit(1, "npc") - outer.margins$top   - outer.margins$bottom,
                         just=c("left", "bottom"), name="main", clip="off")
  pushViewport(vp.main)
  for(i in Nseq)   {
    for(j in Nseq) {
      bg     <- if(i <= dcol   && j <= dcol) bg.col[1] else if(i > dcol && j > dcol) bg.col[3] else bg.col[2]
      labelj <- switch(diagonal, on=j, off=N - j + 1)
      x[is.infinite(x[,i]), i] <- NA
      x[is.infinite(x[,j]), j] <- NA
      vp     <- viewport(x=(labelj - 1)/N, y=1 - i/N, width=1/N, height=1/N, just=c("left", "bottom"), name=as.character(i * N + j))
      pushViewport(vp)
      vp.in  <- viewport(x=0.5, y=0.5, width=1 - gap, height=1 - gap, just=c("center", "center"), name=paste("IN", as.character(i * N + j)))
      pushViewport(vp.in)
      xpos   <- NULL
      if(i == 1 && outer.labels$top[j])    {
        xpos <- FALSE
      }
      if(i == N && outer.labels$bottom[j]) {
        xpos <- TRUE
      }
      ypos   <- NULL
      if(j == N && outer.labels$right[i])  {
        ypos <- FALSE
      }
      if(j == 1 && outer.labels$left[i])   {
        ypos <- TRUE
      }
      if(!is.null(ypos) && diagonal == "off") {
        ypos <- !ypos
      }
      if(i == j) {
        .diag_panel(x[,i], names(x)[i], diag.pars, axis.pars, xpos, ypos, buffer, i, outer.rot)
      } else {
        if(is.factor(x[,i]) + is.factor(x[,j]) == 1) {
          if(i < j & upr.cond != "barcode") .boxplot_panel(x[,j], x[,i], upr.cond, axis.pars, xpos, ypos, buffer, stripplot.pars, outer.rot, bg)
          if(i > j & low.cond != "barcode") .boxplot_panel(x[,j], x[,i], low.cond, axis.pars, xpos, ypos, buffer, stripplot.pars, outer.rot, bg)
          if(i < j & upr.cond == "barcode") {
            pushViewport(viewport(gp=gpar(fill=bg)))
            if(is.factor(x[,i])) {
              barcode(split(x[,j], x[,i])[length(levels(x[,i])):1], horizontal=TRUE, xlim=NULL,
                      labelloc=ypos, axisloc=xpos, labelouter=TRUE,
                      newpage=FALSE, fontsize=axis.pars$fontsize,
                      buffer=buffer, nint=barcode.pars$nint,
                      ptsize=barcode.pars$ptsize, ptpch=barcode.pars$ptpch,
                      bcspace=barcode.pars$bcspace, use.points=barcode.pars$use.points)
            } else {
              if(!is.null(ypos)) ypos <- !ypos
              barcode(split(x[,i], x[,j])[length(levels(x[,j])):1], horizontal=FALSE, xlim=NULL,
                      labelloc=xpos, axisloc=ypos, labelouter=TRUE,
                      newpage=FALSE, fontsize=axis.pars$fontsize,
                      buffer=buffer, nint=barcode.pars$nint,
                      ptsize=barcode.pars$ptsize, ptpch=barcode.pars$ptpch,
                      bcspace=barcode.pars$bcspace, use.points=barcode.pars$use.points)
            }
            popViewport()
          }
          if(i > j & low.cond == "barcode") {
            pushViewport(viewport(gp=gpar(fill=bg)))
            if(is.factor(x[,i])) {
              barcode(split(x[,j], x[,i])[length(levels(x[,i])):1], horizontal=TRUE, xlim=NULL,
                      labelloc=ypos, axisloc=xpos, labelouter=TRUE,
                      newpage=FALSE, fontsize=axis.pars$fontsize,
                      buffer=buffer, nint=barcode.pars$nint,
                      ptsize=barcode.pars$ptsize, ptpch=barcode.pars$ptpch,
                      bcspace=barcode.pars$bcspace, use.points=barcode.pars$use.points)
            } else {
              if(!is.null(ypos)) ypos <- !ypos
              barcode(split(x[,i], x[,j])[length(levels(x[,j])):1], horizontal=FALSE, xlim=NULL,
                      labelloc=xpos, axisloc=ypos, labelouter=TRUE,
                      newpage=FALSE, fontsize=axis.pars$fontsize,
                      buffer=buffer, nint=barcode.pars$nint,
                      ptsize=barcode.pars$ptsize, ptpch=barcode.pars$ptpch,
                      bcspace=barcode.pars$bcspace, use.points=barcode.pars$use.points)
            }
            popViewport()
          }
        }
        if(is.factor(x[,i]) + is.factor(x[,j]) == 0) {
          .scatter_panel(x[,j], x[,i], ifelse(j > dcol && i <= dcol, upr.exp, ifelse(j <= dcol && i <= dcol, ifelse(addEllipses, "ellipses", "points"), low.exp)), scatter.pars, axis.pars, xpos, ypos, buffer, z, G, res, dimens=c(j, i), outer.rot, bg)
        }
        if(is.factor(x[,i]) + is.factor(x[,j]) == 2) {
          .mosaic_panel(x[,j], x[,i], mosaic.pars, axis.pars, xpos, ypos, outer.rot, bg)
        }
      }
      popViewport(1)
      upViewport()
    }
  }
  popViewport()
}

#' @importFrom lattice "panel.lines" "panel.points"
.mvn2D_panel <- function(mu, sigma, k = 15, alone = FALSE, col = rep("grey30", 3), pch = 8, lty = c(1, 2), lwd = c(1, 1)) {
  ev         <- eigen(sigma, symmetric = TRUE)
  s          <- sqrt(rev(sort(ev$values)))
  V          <- ev$vectors[,rev(order(ev$values))]
  theta      <- (0:k) * (pi/(2 * k))
  x          <- s[1]  * cos(theta)
  y          <- s[2]  * sin(theta)
  xy         <- sweep(tcrossprod(cbind(c(x, -x, -x, x), c(y, y, -y, -y)), V), MARGIN=2, STATS=mu, FUN="+")
  l          <- length(x)
  i          <- seq_len(l)
  for(k in seq_len(4)) {
    panel.lines(xy[i,], col=col[1], lty=lty[1], lwd=lwd[1])
    i        <- i + l
  }
  x          <- s[1]
  y          <- s[2]
  xy         <- sweep(tcrossprod(cbind(c(x, -x, 0, 0), c(0, 0, y, -y)),   V), MARGIN=2, STATS=mu, FUN="+")
  panel.lines(xy[1:2,], col=col[2], lty=lty[2], lwd=lwd[2])
  panel.lines(xy[3:4,], col=col[2], lty=lty[2], lwd=lwd[2])
  panel.points(mu[1], mu[2], col=col[3], pch=pch)
    invisible()
}

#' @importFrom grid "gpar" "grid.text" "grid.xaxis" "grid.yaxis" "unit"
.draw_axis <- function(x, y, axis.pars, xpos, ypos, cat.labels = NULL, horiz = NULL, xlim = NULL, ylim = NULL, outer.rot) {
  x        <- as.numeric(x)
  y        <- as.numeric(y)
  if(is.null(xlim)) {
    px     <- pretty(x, axis.pars$n.ticks)
    px     <- px[px > min(x, na.rm=TRUE)    & px < max(x, na.rm=TRUE)]
  } else {
    px     <- pretty(xlim, axis.pars$n.ticks)
    px     <- px[px > min(xlim, na.rm=TRUE) & px < max(xlim, na.rm=TRUE)]
  }
  if(is.null(ylim)) {
    py     <- pretty(y, axis.pars$n.ticks)
    py     <- py[py > min(y, na.rm=TRUE)    & py < max(y, na.rm=TRUE)]
  } else {
    py     <- pretty(ylim, axis.pars$n.ticks)
    py     <- py[py > min(ylim, na.rm=TRUE) & py < max(ylim, na.rm=TRUE)]
  }
  k        <- length(cat.labels)
  if(!is.null(xpos)) {
    if(!is.null(cat.labels) && !horiz) {
      grid.text(cat.labels, x=unit(seq_len(k), "native"), y=unit(rep(1 * (1 - xpos), k), "npc") + unit(rep(-1 * xpos + 1 * (1 - xpos), k), "lines"), rot=outer.rot[1], gp=gpar(fontsize=axis.pars$fontsize))
    } else grid.xaxis(at=px, gp=gpar(fontsize=axis.pars$fontsize), main=xpos)
  }
  if(!is.null(ypos)) {
    if(!is.null(cat.labels) && horiz)  {
      grid.text(cat.labels, y=unit(seq_len(k), "native"), x=unit(rep(1 * (1 - ypos), k), "npc") + unit(rep(-1 * ypos + 1 * (1 - ypos), k), "lines"), rot=outer.rot[2], gp=gpar(fontsize=axis.pars$fontsize))
    } else grid.yaxis(at=py, gp=gpar(fontsize=axis.pars$fontsize), main=ypos)
  }
}

#' @importFrom grid "gpar" "grid.rect" "popViewport" "pushViewport" "viewport"
#' @importFrom lattice "panel.bwplot" "panel.stripplot" "trellis.par.get" "trellis.par.set"
.boxplot_panel <- function(x, y, type, axis.pars, xpos, ypos, buffer, stripplot.pars, outer.rot, bg) {
  xlim         <- NULL
  ylim         <- NULL
  old.color    <- trellis.par.get("box.rectangle")$col
  trellis.par.set(name="box.rectangle", value=list(col="black"))
  trellis.par.set(name="box.umbrella",  value=list(col="black"))
  trellis.par.set(name="box.dot",       value=list(col="black"))
  trellis.par.set(name="plot.symbol",   value=list(col="black"))
  if(is.factor(x)) {
    cat.labels <- levels(x)
    k          <- length(levels(x))
    cat.var    <- as.numeric(x)
    cont.var   <- y
    horiz      <- FALSE
  } else {
    cat.labels <- levels(y)
    k          <- length(levels(y))
    cat.labels <- cat.labels[k:1]
    cat.var    <- k + 1 - as.numeric(y)
    cont.var   <- x
    horiz      <- TRUE
  }
  grid.rect(gp=gpar(fill=bg))
  if(horiz) {
    xlim       <- range(cont.var, na.rm=TRUE) + c(-buffer * (max(cont.var, na.rm=TRUE) - min(cont.var, na.rm=TRUE)), buffer * (max(cont.var, na.rm=TRUE) - min(cont.var, na.rm=TRUE)))
    pushViewport(viewport(xscale=xlim, yscale=c(0.5, max(cat.var, na.rm=TRUE) + 0.5)))
    if(is.null(ypos)) cat.labels <- NULL
    .draw_axis(cont.var, cat.var, axis.pars, xpos, ypos, cat.labels, horiz, xlim, ylim, outer.rot)
    popViewport(1)
    pushViewport(viewport(xscale=xlim, yscale=c(0.5, max(cat.var, na.rm=TRUE) + 0.5), clip=TRUE))
    if(type == "boxplot")   panel.bwplot(cont.var, cat.var, horizontal=horiz, col="black", pch="|", gp=gpar(box.umbrella=list(col="black")))
    if(type == "stripplot") panel.stripplot(cont.var, cat.var, horizontal=horiz, jitter.data=stripplot.pars$jitter, col=stripplot.pars$col, cex=stripplot.pars$size, pch=stripplot.pars$pch)
  } else {
    ylim       <- range(cont.var, na.rm=TRUE) + c(-buffer * (max(cont.var, na.rm=TRUE) - min(cont.var, na.rm=TRUE)), buffer * (max(cont.var, na.rm=TRUE) - min(cont.var, na.rm=TRUE)))
    pushViewport(viewport(yscale=ylim, xscale=c(0.5, max(cat.var, na.rm=TRUE) + 0.5)))
    if(is.null(xpos)) cat.labels <- NULL
    .draw_axis(cat.var, cont.var, axis.pars, xpos, ypos, cat.labels, horiz, xlim, ylim, outer.rot)
    popViewport(1)
    pushViewport(viewport(yscale=ylim, xscale=c(0.5, max(cat.var, na.rm=TRUE) + 0.5), clip=TRUE))
    if(type == "boxplot")   panel.bwplot(cat.var, cont.var, horizontal=horiz, col="black", pch="|", gp=gpar(box.umbrella=list(col="black")))
    if(type == "stripplot") panel.stripplot(cat.var, cont.var, horizontal=horiz, jitter.data=stripplot.pars$jitter,
                                            col=stripplot.pars$col, cex=stripplot.pars$size, pch=stripplot.pars$pch)
  }
  popViewport(1)
  trellis.par.set(name="box.rectangle", value=list(col=old.color))
  trellis.par.set(name="box.umbrella",  value=list(col=old.color))
  trellis.par.set(name="box.dot",       value=list(col=old.color))
  trellis.par.set(name="plot.symbol",   value=list(col=old.color))
}

#' @importFrom grid "gpar" "grid.rect" "grid.text" "popViewport" "pushViewport" "viewport"
#' @importFrom lattice "panel.barchart" "panel.histogram"
.diag_panel <- function(x, varname, diag.pars, axis.pars, xpos, ypos, buffer, i, outer.rot) {
  x         <- x[!is.na(x)]
  xlim      <- range(as.numeric(x), na.rm=TRUE) + c(-buffer * (max(as.numeric(x), na.rm=TRUE) - min(as.numeric(x), na.rm=TRUE)), buffer * (max(as.numeric(x), na.rm=TRUE) - min(as.numeric(x), na.rm=TRUE)))
  ylim      <- xlim
  pushViewport(viewport(xscale=xlim, yscale=ylim))
  .draw_axis(as.numeric(x), as.numeric(x), axis.pars, xpos, ypos, NULL, NULL, xlim, ylim, outer.rot)
  popViewport(1)
  pushViewport(viewport(xscale=xlim, yscale=ylim, clip=TRUE))
  if(!diag.pars$show.hist) {
    grid.rect()
    grid.text(varname, 0.5, 0.5, gp=gpar(fontsize=diag.pars$fontsize, fontface=2))
  }
  popViewport(1)
  if(diag.pars$show.hist)  {
    if(!is.factor(x)) {
      pushViewport(viewport(xscale=xlim, yscale=c(0, 100), clip=TRUE))
      panel.histogram(as.numeric(x), breaks=NULL, type="percent", col=diag.pars$hist.color[i])
    } else {
      pushViewport(viewport(xscale=c(min(as.numeric(x), na.rm=TRUE) - 1, max(as.numeric(x), na.rm=TRUE) + 1), yscale=c(0, 100), clip=TRUE))
      tabx <- table(x)
      panel.barchart(seq_along(tabx), 100 * tabx/sum(tabx), horizontal=FALSE, col=diag.pars$hist.color[i])
    }
    grid.text(varname, 0.5, 0.85, gp=gpar(fontsize=diag.pars$fontsize))
    popViewport(1)
  }
}

#' @importFrom vcd "strucplot"
.mosaic_panel <- function(x, y, mosaic.pars, axis.pars, xpos, ypos, outer.rot, bg) {
  mosaic.pars$gp$fill <- bg
  if(!is.null(xpos)   && !is.null(ypos)) {
    strucplot(table(y, x), margins=c(0, 0, 0, 0), newpage=FALSE, pop=FALSE, keep_aspect_ratio=FALSE, shade=mosaic.pars$shade, legend=FALSE, gp=mosaic.pars$gp,
              gp_args=mosaic.pars$gp_args, labeling_args=list(tl_labels=c(xpos, !ypos), gp_labels=mosaic.pars$gp_labels, varnames=c(FALSE, FALSE), rot_labels=rep(outer.rot, 2)))
  } else {
    if(is.null(xpos)  && is.null(ypos))  {
      strucplot(table(y, x), margins=c(0, 0, 0, 0), shade=mosaic.pars$shade, legend=FALSE, gp=mosaic.pars$gp, gp_args=mosaic.pars$gp_args, newpage=FALSE, pop=FALSE, keep_aspect_ratio=FALSE, labeling=NULL)
    } else {
      if(is.null(xpos)) {
        strucplot(table(y, x), margins=c(0, 0, 0, 0), newpage=FALSE, pop=FALSE, keep_aspect_ratio=FALSE, shade=mosaic.pars$shade, legend=FALSE, gp=mosaic.pars$gp, gp_args = mosaic.pars$gp_args,
                  labeling_args=list(labels=c(TRUE, FALSE), tl_labels=c(ypos, FALSE), gp_labels=mosaic.pars$gp_labels, varnames=c(FALSE, FALSE), rot_labels=rep(outer.rot, 2)))
      } else strucplot(table(y, x), margins=c(0, 0, 0, 0), newpage=FALSE, pop=FALSE, keep_aspect_ratio=FALSE, shade=mosaic.pars$shade, legend=FALSE, gp=mosaic.pars$gp, gp_args = mosaic.pars$gp_args,
                       labeling_args=list(labels=c(FALSE, TRUE), tl_labels=c(FALSE, !xpos), gp_labels=mosaic.pars$gp_labels, varnames=c(FALSE, FALSE), rot_labels=rep(outer.rot, 2)))
    }
  }
}

#' @importFrom grid "gpar" "grid.lines" "grid.points" "grid.rect" "popViewport" "pushViewport" "viewport"
#' @importFrom lattice "panel.abline"
.scatter_panel <- function(x, y, type, scatter.pars, axis.pars, xpos, ypos, buffer, z, G, res, dimens, outer.rot, bg) {
  xlim    <- range(x, na.rm=TRUE) + c(-buffer * (max(x, na.rm=TRUE) - min(x, na.rm=TRUE)), buffer * (max(x, na.rm=TRUE) - min(x, na.rm=TRUE)))
  ylim    <- range(y, na.rm=TRUE) + c(-buffer * (max(y, na.rm=TRUE) - min(y, na.rm=TRUE)), buffer * (max(y, na.rm=TRUE) - min(y, na.rm=TRUE)))
  pushViewport(viewport(xscale=xlim, yscale=ylim))
  .draw_axis(x, y, axis.pars, xpos, ypos, NULL, NULL, xlim, ylim, outer.rot)
  popViewport(1)
  pushViewport(viewport(xscale=xlim, yscale=ylim, clip=TRUE))
  grid.rect(gp=gpar(fill=bg, col=scatter.pars$border.col))
  grid.points(x, y, pch=scatter.pars$pch, size=scatter.pars$size, gp=gpar(col=scatter.pars$col))
  if(type == "ellipses") {
    mu    <- array(res$parameters$mean[dimens,], c(2, G))
    sigma <- array(res$parameters$variance$sigma[dimens, dimens,], c(2, 2, G))
    for(g in seq_len(G)) .mvn2D_panel(mu = mu[,g], sigma = sigma[,,g], k = 15)
  }
  if(type == "lm") {
    for(g in seq_len(G)) {
      xy.lm <- lm(y ~ x, weights=z[,g])
      panel.abline(xy.lm$coef[1], xy.lm$coef[2], col=scatter.pars$lcol[g], lwd=1)
    }
  }
  if(type == "ci") {
    for(g in seq_len(G)) {
      xy.lm <- lm(y ~ x, weights=z[,g])
      xy    <- data.frame(x = seq(min(x, na.rm=TRUE), max(x, na.rm=TRUE), length.out=25))
      yhat  <- predict(xy.lm, newdata=xy, interval="confidence")
      ci    <- data.frame(lower=yhat[, "lwr"], upper=yhat[, "upr"])
      panel.abline(xy.lm$coef[1], xy.lm$coef[2], col=scatter.pars$lcol[g], lwd=1)
      grid.lines(x=xy$x, y=ci$lower, default.units="native", gp=gpar(col=scatter.pars$lcol[g], lwd=1, lty=2))
      grid.lines(x=xy$x, y=ci$upper, default.units="native", gp=gpar(col=scatter.pars$lcol[g], lwd=1, lty=2))
    }
  }
  popViewport(1)
}
